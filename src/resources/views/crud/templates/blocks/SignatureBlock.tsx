import React, {
  useEffect,
  useState,
  useMemo,
  useRef,
  useCallback,
} from "react";
import { BlockContentComponentPorps } from ".";
import { BlockDataType } from "app/Repositories/Block/data";
import {
  SignatureContentAreaProps,
  SignaturePadGroupProps,
} from "app/Hooks/useBuilder";
import { useAuth } from "app/Context/AuthContext";
import Select from "resources/views/components/forms/Select";
import Button from "resources/views/components/forms/Button";
import { useModal } from "app/Context/ModalContext";
import SignatureBlockPad from "../../modals/blocks/SignatureBlockPad";
import useDirectories from "app/Hooks/useDirectories";
import { repo } from "bootstrap/repositories";
import { generateApprovalsFromConfig } from "app/Support/Helpers";
import { useTemplateBoard } from "app/Context/TemplateBoardContext";

const SignatureBlock: React.FC<BlockContentComponentPorps> = ({
  localContentState,
  updateLocal,
  configState,
  blockId,
}) => {
  const { state, actions } = useTemplateBoard();
  const { staff } = useAuth();
  const { openBlock, closeModal } = useModal();
  const { collection: users } = useDirectories(repo("user"), "users");
  const { collection: departments } = useDirectories(
    repo("department"),
    "departments"
  );
  const { collection: groups } = useDirectories(repo("group"), "groups");
  const { collection: carders } = useDirectories(repo("carder"), "carders");
  const identifier: BlockDataType = "approval";

  // Find the current block content from global state
  const currentBlock = state.contents.find((content) => content.id === blockId);
  const currentContent = currentBlock?.content
    ?.approval as SignatureContentAreaProps;

  const [localState, setLocalState] = useState<SignatureContentAreaProps>({
    style: "basic",
    max_signatures: 6,
    approvals: [],
    originator_id: 0,
    originator_name: "",
    originator_department_id: 0,
  });
  const [isAutoGenerated, setIsAutoGenerated] = useState<boolean>(true);
  const lastConfigStateRef = useRef<string>("");
  const isUpdatingRef = useRef<boolean>(false);
  const isInitializedRef = useRef<boolean>(false);

  // Create a stable reference for configState changes
  const configStateHash = useMemo(() => {
    return JSON.stringify({
      from: configState?.from?.state,
      through: configState?.through?.state,
      to: configState?.to?.state,
      approvers: configState?.approvers?.state,
    });
  }, [
    configState?.from?.state,
    configState?.through?.state,
    configState?.to?.state,
    configState?.approvers?.state,
  ]);

  // Stabilize the updateLocal function
  const updateLocalStable = useCallback(
    (data: SignatureContentAreaProps) => {
      updateLocal(data, identifier);
    },
    [updateLocal, identifier]
  );

  const handleResult = useCallback(
    (data: SignatureContentAreaProps) => {
      setLocalState((prev) => ({
        ...prev,
        ...data,
      }));

      // Update global state directly
      if (currentBlock) {
        actions.updateContent(currentBlock.id, data, identifier);
      }

      // Also update local state in parent for compatibility
      updateLocalStable(data);
    },
    [updateLocalStable, currentBlock, actions, identifier]
  );

  // Update approvals when configState changes
  useEffect(() => {
    // Prevent infinite loops
    if (isUpdatingRef.current) {
      return;
    }

    // Check if the configState has actually changed
    if (configStateHash === lastConfigStateRef.current) {
      return;
    }

    lastConfigStateRef.current = configStateHash;

    if (configState && isAutoGenerated) {
      const generatedApprovals = generateApprovalsFromConfig(configState);

      // Check if the generated approvals are different from current ones
      const currentApprovalContent = localState.approvals
        .map((a) => ({
          process_type: a.meta_data?.process_type,
          approval_type: a.approval_type,
          group_id: a.group?.value,
          department_id: a.department?.value,
          approver_id: a.approver?.value,
          order: a.order,
        }))
        .sort((a, b) => a.order - b.order);

      const generatedApprovalContent = generatedApprovals
        .map((a) => ({
          process_type: a.meta_data?.process_type,
          approval_type: a.approval_type,
          group_id: a.group?.value,
          department_id: a.department?.value,
          approver_id: a.approver?.value,
          order: a.order,
        }))
        .sort((a, b) => a.order - b.order);

      const hasChanged =
        JSON.stringify(currentApprovalContent) !==
        JSON.stringify(generatedApprovalContent);

      // Also check if configState has meaningful data
      const configStateHasData =
        configState.from?.state?.staff ||
        configState.from?.state?.group ||
        configState.from?.state?.department ||
        configState.through?.state?.staff ||
        configState.through?.state?.group ||
        configState.through?.state?.department ||
        configState.to?.state?.staff ||
        configState.to?.state?.group ||
        configState.to?.state?.department ||
        (configState.approvers?.state &&
          Array.isArray(configState.approvers.state) &&
          configState.approvers.state.length > 0);

      // Only update if there are generated approvals and they're different from current
      if (
        generatedApprovals.length > 0 &&
        (hasChanged || !configStateHasData)
      ) {
        isUpdatingRef.current = true;

        const newState = {
          ...localState,
          approvals: generatedApprovals,
        };

        setLocalState(newState);

        // Update global state directly
        if (currentBlock) {
          actions.updateContent(currentBlock.id, newState, identifier);
        }

        updateLocalStable(newState);

        // Reset the flag after a short delay
        setTimeout(() => {
          isUpdatingRef.current = false;
        }, 100);
      }
    }
  }, [
    configStateHash,
    isAutoGenerated,
    // Removed ALL problematic dependencies to prevent infinite loops
    // Only essential dependencies remain
  ]);

  // Handle when auto-generation is re-enabled
  useEffect(() => {
    if (isUpdatingRef.current) {
      return;
    }

    if (isAutoGenerated && configState) {
      const generatedApprovals = generateApprovalsFromConfig(configState);

      if (generatedApprovals.length > 0) {
        isUpdatingRef.current = true;

        const newState = {
          ...localState,
          approvals: generatedApprovals,
        };

        setLocalState(newState);

        // Update global state directly
        if (currentBlock) {
          actions.updateContent(currentBlock.id, newState, identifier);
        }

        updateLocalStable(newState);

        // Reset the flag after a short delay
        setTimeout(() => {
          isUpdatingRef.current = false;
        }, 100);
      }
    }
  }, [
    isAutoGenerated,
    // Removed ALL problematic dependencies to prevent infinite loops
    // Only essential dependencies remain
  ]);

  const handleBlockChange = useCallback(
    (detail: unknown) => {
      const updatedRows = [
        {
          ...(detail as SignaturePadGroupProps),
          identifier: crypto.randomUUID(),
        },
        ...localState.approvals,
      ];
      const updatedState: SignatureContentAreaProps = {
        ...localState,
        approvals: updatedRows,
      };

      setLocalState(updatedState);
      setIsAutoGenerated(false); // Mark as manually edited

      // Update global state directly
      if (currentBlock) {
        actions.updateContent(currentBlock.id, updatedState, identifier);
      }

      // Update local state in parent
      updateLocalStable(updatedState);

      closeModal();
    },
    [updateLocalStable, closeModal, currentBlock, actions, identifier]
  ); // Removed localState to prevent infinite loop

  const removeSignatureBlock = useCallback(
    (signature: SignaturePadGroupProps) => {
      const updatedApprovals = localState.approvals.filter(
        (item) => item.identifier !== signature.identifier
      );

      const updatedState: SignatureContentAreaProps = {
        ...localState,
        approvals: updatedApprovals,
      };

      setLocalState(updatedState);
      setIsAutoGenerated(false); // Mark as manually edited

      // Update global state directly
      if (currentBlock) {
        actions.updateContent(currentBlock.id, updatedState, identifier);
      }

      // Update local state in parent
      updateLocalStable(updatedState);
    },
    [updateLocalStable, currentBlock, actions, identifier]
  ); // Removed localState to prevent infinite loop

  const resetToAutoGenerated = useCallback(() => {
    setIsAutoGenerated(true);
    // The useEffect will handle regenerating the approvals
  }, []);

  const forceRefreshApprovals = useCallback(() => {
    if (configState && isAutoGenerated) {
      const generatedApprovals = generateApprovalsFromConfig(configState);

      if (generatedApprovals.length > 0) {
        const newState = {
          ...localState,
          approvals: generatedApprovals,
        };

        setLocalState(newState);

        // Update global state directly
        if (currentBlock) {
          actions.updateContent(currentBlock.id, newState, identifier);
        }

        updateLocalStable(newState);
      }
    }
  }, [
    configState,
    isAutoGenerated,
    updateLocalStable,
    currentBlock,
    actions,
    identifier,
  ]); // Removed localState to prevent infinite loop

  const addApprovalBlock = useCallback(() => {
    openBlock(
      SignatureBlockPad,
      {
        title: "Add Approval Group",
        type: identifier,
        blockState: localState,
        isUpdating: false,
        addBlockComponent: handleBlockChange,
        dependencies: {
          partials: [],
          extras: {
            users,
            departments,
            groups,
            carders,
          },
        },
      },
      identifier
    );
  }, [
    openBlock,
    identifier,
    handleBlockChange,
    users,
    departments,
    groups,
    carders,
  ]); // Removed localState to prevent infinite loop

  // Initialize local state from global state or props - only on mount or when content changes
  useEffect(() => {
    if (isUpdatingRef.current) {
      return;
    }

    // Only initialize if not already initialized or if content has actually changed
    const shouldInitialize =
      !isInitializedRef.current ||
      (currentContent &&
        JSON.stringify(currentContent) !== JSON.stringify(localState));

    if (shouldInitialize) {
      if (currentContent) {
        setLocalState((prev) => ({
          ...prev,
          ...currentContent,
        }));
        isInitializedRef.current = true;
      } else if (staff && !isInitializedRef.current) {
        setLocalState((prev) => ({
          ...prev,
          ...localContentState?.approval,
          originator_id: staff.id,
          originator_name: staff.name,
          originator_department_id: staff.department_id,
        }));
        isInitializedRef.current = true;
      }
    }

    // Cleanup function to reset initialization flag when blockId changes
    return () => {
      isInitializedRef.current = false;
    };
  }, [currentContent, staff, localContentState?.approval, blockId]); // Removed localState to prevent infinite loop

  return (
    <div className="row">
      <div className="col-md-12 mb-3">
        <Select
          label="Style"
          name="style"
          value={localState.style}
          valueKey="value"
          labelKey="label"
          onChange={(e) =>
            handleResult({
              ...localState,
              style: e.target.value as
                | "boxed"
                | "tabular"
                | "stacked"
                | "basic",
            })
          }
          options={[
            { value: "boxed", label: "Boxed" },
            { value: "tabular", label: "Tabular" },
            { value: "stacked", label: "Stacked" },
            { value: "basic", label: "Basic" },
          ]}
          defaultValue=""
          defaultCheckDisabled
        />
      </div>

      <div className="col-md-12 mb-3">
        <div className="d-flex justify-content-between align-items-center">
          <div className="form-check">
            <input
              className="form-check-input"
              type="checkbox"
              id="autoGenerate"
              checked={isAutoGenerated}
              onChange={(e) => setIsAutoGenerated(e.target.checked)}
            />
            <label className="form-check-label" htmlFor="autoGenerate">
              Auto-generate from process flow
            </label>
          </div>
          {isAutoGenerated && (
            <small className="text-muted">
              <i className="ri-information-line me-1"></i>
              Approvals will be automatically generated from From → Through → To
            </small>
          )}
          {!isAutoGenerated && (
            <Button
              label="Reset to Auto"
              icon="ri-refresh-line"
              size="xs"
              handleClick={resetToAutoGenerated}
              variant="info"
            />
          )}
          <Button
            label="Force Refresh"
            icon="ri-refresh-line"
            size="xs"
            handleClick={forceRefreshApprovals}
            variant="warning"
          />
        </div>
      </div>

      <div className="col-md-12 mb-3">
        <Button
          label="Add Approval Group"
          icon="ri-add-line"
          size="sm"
          handleClick={addApprovalBlock}
          variant="dark"
          isDisabled={isAutoGenerated}
        />
      </div>

      <div className="col-md-12 mb-5">
        {localState.approvals.length > 0 ? (
          localState.approvals.map((approval, idx) => (
            <div
              className="signature__block flex align between gap-lg"
              key={idx}
            >
              <div className="signature__details">
                <h5 className="mb-2">
                  {approval.group?.label || "No Group"}
                  {approval.meta_data &&
                    typeof approval.meta_data === "object" &&
                    "process_type" in approval.meta_data && (
                      <span className="badge bg-info ms-2">
                        {String(approval.meta_data.process_type)}
                      </span>
                    )}
                </h5>
                <p>
                  {approval.approver?.label || "Default Approving Staff"} |{" "}
                  {approval.department?.label || "No Department"} |{" "}
                  {approval.approval_type}
                </p>
              </div>
              <div className="signature__config">
                <Button
                  icon="ri-close-large-line"
                  handleClick={() => removeSignatureBlock(approval)}
                  variant="danger"
                  size="xs"
                  isDisabled={isAutoGenerated}
                />
              </div>
            </div>
          ))
        ) : (
          <p className="text-muted">
            {isAutoGenerated
              ? "No approval groups configured in process flow yet."
              : "No approval groups added yet."}
          </p>
        )}
      </div>
    </div>
  );
};

export default SignatureBlock;
