import React, { useEffect, useState, useMemo, useRef } from "react";
import { BlockContentComponentPorps } from ".";
import { BlockDataType } from "app/Repositories/Block/data";
import {
  SignatureContentAreaProps,
  SignaturePadGroupProps,
} from "app/Hooks/useBuilder";
import { useAuth } from "app/Context/AuthContext";
import Select from "resources/views/components/forms/Select";
import Button from "resources/views/components/forms/Button";
import { useModal } from "app/Context/ModalContext";
import SignatureBlockPad from "../../modals/blocks/SignatureBlockPad";
import useDirectories from "app/Hooks/useDirectories";
import { repo } from "bootstrap/repositories";
import { generateApprovalsFromConfig } from "app/Support/Helpers";

const SignatureBlock: React.FC<BlockContentComponentPorps> = ({
  localContentState,
  updateLocal,
  configState,
}) => {
  const { staff } = useAuth();
  const { openBlock, closeModal } = useModal();
  const { collection: users } = useDirectories(repo("user"), "users");
  const { collection: departments } = useDirectories(
    repo("department"),
    "departments"
  );
  const { collection: groups } = useDirectories(repo("group"), "groups");
  const { collection: carders } = useDirectories(repo("carder"), "carders");
  const identifier: BlockDataType = "approval";
  const [state, setState] = useState<SignatureContentAreaProps>({
    style: "basic",
    max_signatures: 6,
    approvals: [],
    originator_id: 0,
    originator_name: "",
    originator_department_id: 0,
  });
  const [isAutoGenerated, setIsAutoGenerated] = useState<boolean>(true);
  const lastConfigStateRef = useRef<string>("");

  // Create a stable reference for configState changes
  const configStateHash = useMemo(() => {
    return JSON.stringify({
      from: configState?.from?.state,
      through: configState?.through?.state,
      to: configState?.to?.state,
    });
  }, [
    configState?.from?.state,
    configState?.through?.state,
    configState?.to?.state,
  ]);

  const handleResult = (data: SignatureContentAreaProps) => {
    setState((prev) => ({
      ...prev,
      ...data,
    }));

    updateLocal(data, identifier);
  };

  // Function to generate signature approvals from configState

  // Update approvals when configState changes
  useEffect(() => {
    // console.log("SignatureBlock: configStateHash changed", configStateHash);
    // console.log("SignatureBlock: isAutoGenerated", isAutoGenerated);
    // console.log(
    //   "SignatureBlock: lastConfigStateRef.current",
    //   lastConfigStateRef.current
    // );

    // Check if the configState has actually changed
    if (configStateHash === lastConfigStateRef.current) {
      // console.log("SignatureBlock: No actual change detected, skipping update");
      return;
    }

    lastConfigStateRef.current = configStateHash;

    if (configState && isAutoGenerated) {
      const generatedApprovals = generateApprovalsFromConfig(configState);
      // console.log("SignatureBlock: generatedApprovals", generatedApprovals);

      // Check if the generated approvals are different from current ones
      // Compare the actual content, not the randomly generated identifiers
      const currentApprovalContent = state.approvals
        .map((a) => ({
          process_type: a.meta_data?.process_type,
          approval_type: a.approval_type,
          group_id: a.group?.value,
          department_id: a.department?.value,
          approver_id: a.approver?.value,
          order: a.order,
        }))
        .sort((a, b) => a.order - b.order);

      const generatedApprovalContent = generatedApprovals
        .map((a) => ({
          process_type: a.meta_data?.process_type,
          approval_type: a.approval_type,
          group_id: a.group?.value,
          department_id: a.department?.value,
          approver_id: a.approver?.value,
          order: a.order,
        }))
        .sort((a, b) => a.order - b.order);

      const hasChanged =
        JSON.stringify(currentApprovalContent) !==
        JSON.stringify(generatedApprovalContent);

      // Also check if configState has meaningful data
      const configStateHasData =
        configState.from?.state?.staff ||
        configState.from?.state?.group ||
        configState.from?.state?.department ||
        configState.through?.state?.staff ||
        configState.through?.state?.group ||
        configState.through?.state?.department ||
        configState.to?.state?.staff ||
        configState.to?.state?.group ||
        configState.to?.state?.department;

      // console.log("SignatureBlock: configStateHasData", configStateHasData);

      // Only update if there are generated approvals and they're different from current
      if (
        generatedApprovals.length > 0 &&
        (hasChanged || !configStateHasData)
      ) {
        // console.log("SignatureBlock: Updating approvals");
        setState((prev) => ({
          ...prev,
          approvals: generatedApprovals,
        }));

        // Update the local content state
        updateLocal(
          {
            ...state,
            approvals: generatedApprovals,
          },
          identifier
        );
      }
    }
  }, [
    configStateHash,
    isAutoGenerated,
    configState,
    updateLocal,
    identifier,
    state.approvals,
  ]);

  // Handle when auto-generation is re-enabled
  useEffect(() => {
    if (isAutoGenerated && configState) {
      const generatedApprovals = generateApprovalsFromConfig(configState);

      if (generatedApprovals.length > 0) {
        setState((prev) => ({
          ...prev,
          approvals: generatedApprovals,
        }));

        updateLocal(
          {
            ...state,
            approvals: generatedApprovals,
          },
          identifier
        );
      }
    }
  }, [isAutoGenerated]);

  const handleBlockChange = (detail: unknown) => {
    const updatedRows = [
      {
        ...(detail as SignaturePadGroupProps),
        identifier: crypto.randomUUID(),
      },
      ...state.approvals,
    ];
    const updatedState: SignatureContentAreaProps = {
      ...state,
      approvals: updatedRows,
    };

    setState(updatedState);
    setIsAutoGenerated(false); // Mark as manually edited
    updateLocal(updatedState, "approval");

    closeModal();
  };

  const removeSignatureBlock = (signature: SignaturePadGroupProps) => {
    const updatedApprovals = state.approvals.filter(
      (item) => item.identifier !== signature.identifier
    );

    const updatedState: SignatureContentAreaProps = {
      ...state,
      approvals: updatedApprovals,
    };

    setState(updatedState);
    setIsAutoGenerated(false); // Mark as manually edited
    updateLocal(updatedState, "approval");
  };

  const resetToAutoGenerated = () => {
    setIsAutoGenerated(true);
    // The useEffect will handle regenerating the approvals
  };

  const forceRefreshApprovals = () => {
    if (configState && isAutoGenerated) {
      const generatedApprovals = generateApprovalsFromConfig(configState);

      if (generatedApprovals.length > 0) {
        setState((prev) => ({
          ...prev,
          approvals: generatedApprovals,
        }));

        updateLocal(
          {
            ...state,
            approvals: generatedApprovals,
          },
          identifier
        );
      }
    }
  };

  const addApprovalBlock = () => {
    openBlock(
      SignatureBlockPad,
      {
        title: "Add Approval Group",
        type: identifier,
        blockState: state,
        isUpdating: false,
        addBlockComponent: handleBlockChange,
        dependencies: {
          partials: [],
          extras: {
            users,
            departments,
            groups,
            carders,
          },
        },
      },
      identifier
    );
  };

  useEffect(() => {
    if (!staff) return;
    setState((prev) => ({
      ...prev,
      ...localContentState?.approval,
      originator_id: staff.id,
      originator_name: staff.name,
      originator_department_id: staff.department_id,
    }));
  }, [staff, localContentState?.approval]);

  return (
    <div className="row">
      <div className="col-md-12 mb-3">
        <Select
          label="Style"
          name="style"
          value={state.style}
          valueKey="value"
          labelKey="label"
          onChange={(e) =>
            handleResult({
              ...state,
              style: e.target.value as
                | "boxed"
                | "tabular"
                | "stacked"
                | "basic",
            })
          }
          options={[
            { value: "boxed", label: "Boxed" },
            { value: "tabular", label: "Tabular" },
            { value: "stacked", label: "Stacked" },
            { value: "basic", label: "Basic" },
          ]}
          defaultValue=""
          defaultCheckDisabled
        />
      </div>

      <div className="col-md-12 mb-3">
        <div className="d-flex justify-content-between align-items-center">
          <div className="form-check">
            <input
              className="form-check-input"
              type="checkbox"
              id="autoGenerate"
              checked={isAutoGenerated}
              onChange={(e) => setIsAutoGenerated(e.target.checked)}
            />
            <label className="form-check-label" htmlFor="autoGenerate">
              Auto-generate from process flow
            </label>
          </div>
          {isAutoGenerated && (
            <small className="text-muted">
              <i className="ri-information-line me-1"></i>
              Approvals will be automatically generated from From → Through → To
            </small>
          )}
          {!isAutoGenerated && (
            <Button
              label="Reset to Auto"
              icon="ri-refresh-line"
              size="xs"
              handleClick={resetToAutoGenerated}
              variant="info"
            />
          )}
          <Button
            label="Force Refresh"
            icon="ri-refresh-line"
            size="xs"
            handleClick={forceRefreshApprovals}
            variant="warning"
          />
        </div>
      </div>

      <div className="col-md-12 mb-3">
        <Button
          label="Add Approval Group"
          icon="ri-add-line"
          size="sm"
          handleClick={addApprovalBlock}
          variant="dark"
          isDisabled={isAutoGenerated}
        />
      </div>

      <div className="col-md-12 mb-5">
        {state.approvals.length > 0 ? (
          state.approvals.map((approval, idx) => (
            <div
              className="signature__block flex align between gap-lg"
              key={idx}
            >
              <div className="signature__details">
                <h5 className="mb-2">
                  {approval.group?.label || "No Group"}
                  {approval.meta_data &&
                    typeof approval.meta_data === "object" &&
                    "process_type" in approval.meta_data && (
                      <span className="badge bg-info ms-2">
                        {String(approval.meta_data.process_type)}
                      </span>
                    )}
                </h5>
                <p>
                  {approval.approver?.label || "Default Approving Staff"} |{" "}
                  {approval.department?.label || "No Department"} |{" "}
                  {approval.approval_type}
                </p>
              </div>
              <div className="signature__config">
                <Button
                  icon="ri-close-large-line"
                  handleClick={() => removeSignatureBlock(approval)}
                  variant="danger"
                  size="xs"
                  isDisabled={isAutoGenerated}
                />
              </div>
            </div>
          ))
        ) : (
          <p className="text-muted">
            {isAutoGenerated
              ? "No approval groups configured in process flow yet."
              : "No approval groups added yet."}
          </p>
        )}
      </div>
    </div>
  );
};

export default SignatureBlock;
